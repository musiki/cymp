<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>KHI</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a0a0a;
      overflow: hidden;
      touch-action: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: auto; /* smooth upscale */
    }
  </style>
</head>
<body>
  <canvas id="view"></canvas>

  <script>
/* Kelvin–Helmholtz (KHI) toy: convective Cahn–Hilliard on a 2D grid.
   Fullscreen canvas, offscreen low-res simulation buffer for speed,
   dynamic (slowly varying shear + gentle stochastic seeding). */

(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  // Device pixel ratio for crisp scaling
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    // smoothing on for fluid look
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Simulation grid size (decoupled from screen size).
  // Go denser on wide screens; don't worry about resolution per your note.
  const base = Math.max(220, Math.floor(window.innerWidth * 0.35));
  const Nx = base;
  const Ny = Math.max(120, Math.floor(base * (window.innerHeight / window.innerWidth) * 0.5));

  // Physical extents (dimensionless)
  const Lx = 1.0, Ly = 1.0;
  const dx = Lx / Nx, dy = Ly / Ny;

  // Offscreen buffer to draw the field and upscale onto the main canvas
  const off = document.createElement('canvas');
  off.width = Nx; off.height = Ny;
  const octx = off.getContext('2d', { willReadFrequently: true });
  let img = octx.createImageData(Nx, Ny);
  let pix = img.data;

  // Fields
  const N = Nx * Ny;
  const c    = new Float32Array(N);
  const cNew = new Float32Array(N);
  const mu   = new Float32Array(N);
  const lapC = new Float32Array(N);
  const u    = new Float32Array(N);
  const v    = new Float32Array(N);

  // Parameters
  const eps = 0.012 / Math.SQRT2;   // interface thickness
  const M   = 1.0;                  // mobility
  const CFL = 0.35;                 // a bit higher; we substep
  let   substepsPerFrame = 6;       // fluid feel

  // Helpers
  const I = (i, j) => i + j * Nx;
  const wrapI = i => (i < 0 ? i + Nx : (i >= Nx ? i - Nx : i));
  const clampJ = j => (j < 0 ? 0 : (j >= Ny ? Ny - 1 : j));

  // Initialization: tanh shear layer + sinusoidal perturbation
  function init(t = 0) {
    for (let j = 0; j < Ny; j++) {
      const y = (j + 0.5) * dy;
      for (let i = 0; i < Nx; i++) {
        const x = (i + 0.5) * dx;
        const a = 2.0, b = 0.5;
        const perturb = 0.01 * Math.sin(a * Math.PI * x);
        const denom = 2.0 * Math.sqrt(2) * eps;
        const l = Math.tanh((y - b - perturb) / denom);
        c[I(i,j)] = 0.5 * (1 + l);
      }
    }
    updateVelocity(0);
  }

  // Time-varying shear to keep things evolving
  function updateVelocity(t) {
    // slow breathing factor in [-0.15, 0.15]
    const breathe = 0.15 * Math.sin(2 * Math.PI * (t * 0.03));
    for (let j = 0; j < Ny; j++) {
      const y = (j + 0.5) * dy;
      for (let i = 0; i < Nx; i++) {
        const x = (i + 0.5) * dx;
        const denom = 2.0 * Math.sqrt(2) * eps;
        const l = Math.tanh((y - 0.5) / denom);
        // base shear + a tiny x-dependent warp that oscillates in time
        const uu = l + breathe * Math.sin(2 * Math.PI * x);
        u[I(i,j)] = uu;
        v[I(i,j)] = 0.0;
      }
    }
  }

  // Laplacian (5-point)
  function laplacian(src, out) {
    const invdx2 = 1 / (dx*dx), invdy2 = 1 / (dy*dy);
    for (let j = 0; j < Ny; j++) {
      const jm = clampJ(j - 1), jp = clampJ(j + 1);
      for (let i = 0; i < Nx; i++) {
        const im = wrapI(i - 1), ip = wrapI(i + 1);
        const cC = src[I(i,j)];
        out[I(i,j)] =
          (src[I(im,j)] - 2*cC + src[I(ip,j)]) * invdx2 +
          (src[I(i,jm)] - 2*cC + src[I(i,jp)]) * invdy2;
      }
    }
  }

  // Upwind advection
  function advectC(dt) {
    for (let j = 0; j < Ny; j++) {
      const jm = clampJ(j - 1), jp = clampJ(j + 1);
      for (let i = 0; i < Nx; i++) {
        const im = wrapI(i - 1), ip = wrapI(i + 1);
        const U = u[I(i,j)], V = v[I(i,j)];
        const cC = c[I(i,j)];
        const dcdx = U >= 0
          ? (cC - c[I(im,j)]) / dx
          : (c[I(ip,j)] - cC) / dx;
        const dcdy = V >= 0
          ? (cC - c[I(i,jm)]) / dy
          : (c[I(i,jp)] - cC) / dy;
        cNew[I(i,j)] = cC - dt * (U * dcdx + V * dcdy);
      }
    }
    c.set(cNew);
  }

  // Cahn–Hilliard diffusion step
  function diffuseCH(dt) {
    laplacian(c, lapC);
    for (let k = 0; k < N; k++) {
      const cc = c[k];
      const f = cc * (cc - 0.5) * (cc - 1.0);
      mu[k] = f - (eps * eps) * lapC[k];
    }
    laplacian(mu, lapC);
    for (let k = 0; k < N; k++) c[k] += dt * M * lapC[k];
  }

  // Gentle stochastic kick near the interface to keep small-scale features alive
  function seedNoise(strength = 0.0005) {
    for (let j = 1; j < Ny - 1; j++) {
      for (let i = 0; i < Nx; i++) {
        const k = I(i,j);
        const cc = c[k];
        const w = Math.exp(-100 * Math.abs(cc - 0.5)); // focus around interface
        if (w > 1e-3) c[k] = Math.min(1, Math.max(0, cc + (Math.random() - 0.5) * strength * w));
      }
    }
  }

  // Time step based on CFL & CH heuristics
  function computeDt() {
    let umax = 1e-8;
    for (let k = 0; k < N; k++) { const s = Math.abs(u[k]); if (s > umax) umax = s; }
    const dtAdv = CFL * Math.min(dx / umax, dy / umax);
    const nuCH = M * (1/(dx*dx) + 1/(dy*dy)) * (eps*eps + 1);
    const dtDiff = 0.12 / (nuCH || 1e-6);
    return Math.min(dtAdv, dtDiff);
  }

  // Color map (0→blue, 0.5→white, 1→red), written to offscreen ImageData
  function drawField() {
    let p = 0;
    for (let j = 0; j < Ny; j++) {
      for (let i = 0; i < Nx; i++) {
        const val = c[I(i,j)];
        const t = Math.max(0, Math.min(1, val));
        const r = t * 255;
        const b = (1 - t) * 255;
        const g = 255 * (1 - Math.abs(t - 0.5) * 2);
        pix[p++] = r;   // R
        pix[p++] = g;   // G
        pix[p++] = b;   // B
        pix[p++] = 255; // A
      }
    }
    octx.putImageData(img, 0, 0);
    // upscale to full screen
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(off, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
  }

  // Animation loop
  let tSim = 0;
  init(0);
  let dt = computeDt();

  function step() {
    // slowly vary shear
    updateVelocity(tSim);

    // adaptive substeps when fast
    dt = computeDt();
    const targetSubsteps = Math.max(4, Math.min(10, Math.floor(0.008 / dt)));
    substepsPerFrame = targetSubsteps;

    for (let s = 0; s < substepsPerFrame; s++) {
      advectC(dt);
      diffuseCH(dt);
      if ((s & 3) === 0) seedNoise(0.00035); // gentle nudge every few substeps
      tSim += dt;
    }
    drawField();
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
})();
  </script>
</body>
</html>