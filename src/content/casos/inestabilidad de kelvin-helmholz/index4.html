<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>KHI • Canvas + Sonification</title>
<style>
  html,body{margin:0;height:100%;background:#0a0a0a;overflow:hidden;font-family:ui-monospace,Menlo,Consolas,monospace}
  #view{display:block;width:100vw;height:100vh;image-rendering:auto}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.85);color:#eee;z-index:10}
  #overlay .panel{max-width:720px;text-align:center;padding:24px}
  #overlay h2{margin:0 0 8px 0;font-weight:700;color:#fff}
  #overlay p{margin:0 0 14px 0;color:#cfcfcf}
  #overlay button{border:0;border-radius:14px;padding:12px 18px;font-size:15px;cursor:pointer;box-shadow:0 0 0 1px #555 inset;background:#1f1f1f;color:#eee}
  #overlay button:hover{background:#262626}
  #hud{position:fixed;left:12px;bottom:10px;color:#bdbdbd;font-size:12px;line-height:1.25;user-select:none;z-index:5}
  #hud div{display:flex;gap:8px}
  #hud span{display:inline-block;min-width:68px;opacity:.85}
  #hud b{color:#f0f0f0;font-weight:700}
  #lamp{width:10px;height:10px;border-radius:50%;background:#444;border:1px solid #222;display:inline-block;margin-left:8px;vertical-align:-1px}
  #lamp.on{background:#22c55e}
</style>
</head>
<body>
  <canvas id="view"></canvas>

  <div id="overlay">
    <div class="panel">
      <h2>Kelvin–Helmholtz: instrumento web</h2>
      <p>Click to start AudioContext. Drag mouse in X to change k. Scroll to adjust shear U0. The interface breathes over time.</p>
      <button id="start">Start simulation + audio <span id="lamp"></span></button>
    </div>
  </div>

  <div id="hud">
    <div><span>grid</span><b id="grid">—</b></div>
    <div><span>U0</span><b id="u0">—</b></div>
    <div><span>δ/Ly</span><b id="delta">—</b></div>
    <div><span>k</span><b id="kval">—</b></div>
    <div><span>gain</span><b id="gain">— dB</b></div>
    <div><span>status</span><b id="status">ready</b></div>
  </div>

<script>
(() => {
  const statusEl = document.getElementById('status');

  // ---------- Canvas ----------
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ---------- Grid ----------
  const base = Math.max(260, Math.floor(window.innerWidth * 0.42));
  const Nx = base;
  const Ny = Math.max(150, Math.floor(base * (window.innerHeight / window.innerWidth) * 0.55));
  document.getElementById('grid').textContent = `${Nx}×${Ny}`;

  const Lx = 1.0, Ly = 1.0;
  const dx = Lx / Nx, dy = Ly / Ny;

  // Offscreen
  const off = document.createElement('canvas');
  off.width = Nx; off.height = Ny;
  const octx = off.getContext('2d', { willReadFrequently: true });
  const img = octx.createImageData(Nx, Ny);
  const pix = img.data;

  // ---------- Fields ----------
  const N = Nx * Ny;
  const c    = new Float32Array(N);
  const cNew = new Float32Array(N);
  const mu   = new Float32Array(N);
  const lapC = new Float32Array(N);
  const u    = new Float32Array(N);
  const v    = new Float32Array(N);

  // ---------- Params / Interaction ----------
  let U0 = 0.60;
  let delta0 = 0.22;
  let delta = delta0;
  let k = 1.20;
  let wheel = 0.0;

  document.getElementById('u0').textContent = U0.toFixed(2);
  document.getElementById('delta').textContent = delta0.toFixed(2);
  document.getElementById('kval').textContent = k.toFixed(2);

  const eps = 0.012 / Math.SQRT2;
  const M   = 1.0;
  const CFL = 0.35;
  let substepsPerFrame = 6;

  const I = (i,j) => i + j * Nx;
  const wrapI = i => (i < 0 ? i + Nx : (i >= Nx ? i - Nx : i));
  const clampJ = j => (j < 0 ? 0 : (j >= Ny ? Ny - 1 : j));
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp  = (a,b,t)=>a + (b-a)*t;

  let pointerX = 0.0;
  window.addEventListener('mousemove', e => {
    pointerX = (e.clientX / innerWidth - 0.5) * 2.0;
  }, {passive:true});

  window.addEventListener('wheel', e => {
    wheel += Math.sign(e.deltaY) * 0.05;
    U0 = clamp(U0 + (-Math.sign(e.deltaY)) * 0.03, 0.2, 1.5);
    document.getElementById('u0').textContent = U0.toFixed(2);
  }, {passive:true});

  // ---------- Init field ----------
  function initField() {
    for (let j = 0; j < Ny; j++) {
      const y = (j + 0.5) * dy;
      for (let i = 0; i < Nx; i++) {
        const x = (i + 0.5) * dx;
        const y0 = 0.5 + 0.01 * Math.sin(2*Math.PI * x);
        const denom = 2.0 * Math.sqrt(2) * eps;
        const l = Math.tanh((y - y0) / denom);
        c[I(i,j)] = 0.5 * (1 + l);
      }
    }
  }
  initField();

  // ---------- Velocity field ----------
  function updateVelocity(t) {
    delta = clamp( delta0 + 0.10 * Math.sin(t*0.15 + wheel), 0.10, 0.42 );
    document.getElementById('delta').textContent = delta.toFixed(2);

    k = clamp(1.2 + pointerX*0.9, 0.2, 2.5);
    document.getElementById('kval').textContent = k.toFixed(2);

    const denom = 2.0 * Math.sqrt(2) * eps;
    const A = 0.08 * Math.exp(-Math.abs(delta - delta0) / 0.25);
    const omega = 1.2;

    for (let j = 0; j < Ny; j++) {
      const y = (j + 0.5) * dy;
      for (let i = 0; i < Nx; i++) {
        const x = (i + 0.5) * dx;
        const phase = 2*Math.PI * (k * x) - omega * t;
        const y0 = 0.5 + A * Math.sin(phase);
        const arg = (y - y0) / (delta * denom);
        const l = Math.tanh(arg);

        const uu = U0 * l;
        const sech = 1/Math.cosh(arg);
        const dUdy = (U0 / (delta * denom)) * (sech*sech);
        const vv = 0.05 * dUdy * Math.cos(phase);

        u[I(i,j)] = uu;
        v[I(i,j)] = vv;
      }
    }
  }

  // ---------- Numerics ----------
  function laplacian(src, out) {
    const invdx2 = 1 / (dx*dx), invdy2 = 1 / (dy*dy);
    for (let j = 0; j < Ny; j++) {
      const jm = clampJ(j - 1), jp = clampJ(j + 1);
      for (let i = 0; i < Nx; i++) {
        const im = wrapI(i - 1), ip = wrapI(i + 1);
        const cC = src[I(i,j)];
        out[I(i,j)] =
          (src[I(im,j)] - 2*cC + src[I(ip,j)]) * invdx2 +
          (src[I(i,jm)] - 2*cC + src[I(i,jp)]) * invdy2;
      }
    }
  }

  function advectC(dt) {
    for (let j = 0; j < Ny; j++) {
      const jm = clampJ(j - 1), jp = clampJ(j + 1);
      for (let i = 0; i < Nx; i++) {
        const im = wrapI(i - 1), ip = wrapI(i + 1);
        const U = u[I(i,j)], V = v[I(i,j)];
        const cC = c[I(i,j)];
        const dcdx = U >= 0 ? (cC - c[I(im,j)]) / dx : (c[I(ip,j)] - cC) / dx;
        // FIX: se había colado un paréntesis extra aquí
        const dcdy = V >= 0 ? (cC - c[I(i,jm)]) / dy : (c[I(i,jp)] - cC) / dy;
        cNew[I(i,j)] = cC - dt * (U * dcdx + V * dcdy);
      }
    }
    c.set(cNew);
  }

  function diffuseCH(dt) {
    laplacian(c, lapC);
    for (let k2 = 0; k2 < N; k2++) {
      const cc = c[k2];
      const f = cc * (cc - 0.5) * (cc - 1.0);
      mu[k2] = f - (eps * eps) * lapC[k2];
    }
    laplacian(mu, lapC);
    for (let k2 = 0; k2 < N; k2++) c[k2] += dt * M * lapC[k2];
  }

  function seedNoise(strength = 0.00028) {
    for (let j = 1; j < Ny - 1; j++) {
      for (let i = 0; i < Nx; i++) {
        const idx = I(i,j);
        const cc = c[idx];
        const w = Math.exp(-120 * Math.abs(cc - 0.5));
        if (w > 1e-3) c[idx] = clamp(cc + (Math.random() - 0.5) * strength * w, 0, 1);
      }
    }
  }

  function computeDt() {
    let umax = 1e-8, vmax = 1e-8;
    for (let k2 = 0; k2 < N; k2++) {
      const au = Math.abs(u[k2]); if (au > umax) umax = au;
      const av = Math.abs(v[k2]); if (av > vmax) vmax = av;
    }
    const dtAdv = CFL * Math.min(dx / umax, dy / vmax);
    const nuCH = M * (1/(dx*dx) + 1/(dy*dy)) * (eps*eps + 1);
    const dtDiff = 0.12 / (nuCH || 1e-6);
    return Math.min(dtAdv, dtDiff);
  }

  // ---------- Rendering ----------
  function drawField() {
    let p = 0;
    for (let j = 0; j < Ny; j++) {
      for (let i = 0; i < Nx; i++) {
        const val = c[I(i,j)];
        const t = Math.max(0, Math.min(1, val));
        const r = t * 255;
        const b = (1 - t) * 255;
        const g = 255 * (1 - Math.abs(t - 0.5) * 2);
        pix[p++] = r; pix[p++] = g; pix[p++] = b; pix[p++] = 255;
      }
    }
    octx.putImageData(img, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(off, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
  }

  // ---------- Feature extraction ----------
  function extractFeatures() {
    let wSum=0, xSum=0, ySum=0, shearSum=0, vSum=0;
    for (let j = 1; j < Ny - 1; j++) {
      for (let i = 0; i < Nx; i++) {
        const idx = I(i,j);
        const cc = c[idx];
        const w = Math.exp(-80 * Math.abs(cc - 0.5));
        if (w > 1e-6) {
          wSum += w;
          xSum += w * ((i+0.5)/Nx);
          ySum += w * ((j+0.5)/Ny);
          const jm = j-1, jp=j+1;
          const du = (u[I(i,jp)] - u[I(i,jm)]) * 0.5 / dy;
          shearSum += w * Math.abs(du);
          vSum += w * Math.abs(v[idx]);
        }
      }
    }
    if (wSum < 1e-9) return {x:0.5,y:0.5,energy:0,sharp:0};
    const x = xSum/wSum, y = ySum/wSum;
    const shear = shearSum/wSum;
    const vyavg = vSum/wSum;
    const shearN = Math.min(1, shear * 0.2);
    const vyN    = Math.min(1, vyavg * 10);
    const energy = clamp(0.55*shearN + 0.45*vyN, 0, 1);
    return { x, y, energy, sharp: shearN };
  }

  // ---------- Web Audio ----------
  const startBtn = document.getElementById('start');
  const lamp = document.getElementById('lamp');
  let audioCtx=null, noiseSrc=null, filter=null, panner=null, gainNode=null, comp=null;
  let audioOn=false, started=false;

  function dbToGain(db){ return Math.pow(10, db/20); }

  function makeWhiteNoiseBuffer(ctx, seconds = 3) {
    const rate = ctx.sampleRate, len = Math.floor(seconds*rate);
    const buf = ctx.createBuffer(2, len, rate);
    for (let ch=0; ch<2; ch++){
      const d = buf.getChannelData(ch);
      for (let i=0;i<len;i++) d[i] = Math.random()*2-1;
    }
    return buf;
  }

  function setupAudio(){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    noiseSrc = audioCtx.createBufferSource();
    noiseSrc.buffer = makeWhiteNoiseBuffer(audioCtx, 4);
    noiseSrc.loop = true;

    filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 800;
    filter.Q.value = 2;

    panner = audioCtx.createStereoPanner();
    panner.pan.value = 0;

    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.0;

    comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -10;
    comp.knee.value = 10;
    comp.ratio.value = 12;
    comp.attack.value = 0.004;
    comp.release.value = 0.12;

    noiseSrc.connect(filter);
    filter.connect(panner);
    panner.connect(gainNode);
    gainNode.connect(comp).connect(audioCtx.destination);

    noiseSrc.start();
  }

  async function startAudio() {
    if (started) return; // evita loops de click
    started = true;
    try{
      if (!audioCtx) setupAudio();
      await audioCtx.resume();
      audioOn = true;
      lamp.classList.add('on');
      startBtn.textContent = 'Audio running';
      statusEl.textContent = 'audio ok';
    } catch (err){
      statusEl.textContent = 'audio error: ' + (err && err.message ? err.message : err);
      started = false; // permite reintentar
    }
  }

  startBtn.addEventListener('click', () => {
    document.getElementById('overlay').style.display='none';
    startAudio();
  });

  function smoothParam(param, target, tc=0.07) {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    try { param.setTargetAtTime(target, now, tc); } catch(e) {}
  }

  function updateAudio(feat, t) {
    if (!audioOn || !audioCtx) return;
    const freq = 200 + 4200 * feat.y;
    const Q    = 0.8 + 18.0 * feat.sharp;
    const lfo  = 0.15 * Math.sin(2*Math.PI*t*0.08);
    const g    = clamp(0.05 + 0.22*feat.energy + lfo, 0, 0.28);
    const pan  = -1 + 2 * feat.x;

    smoothParam(filter.frequency, freq, 0.10);
    smoothParam(filter.Q, Q, 0.12);
    smoothParam(gainNode.gain, g, 0.20);
    smoothParam(panner.pan, pan, 0.12);

    const gdb = 20*Math.log10(Math.max(1e-6,g));
    document.getElementById('gain').textContent = gdb.toFixed(1)+' dB';
  }

  // ---------- Main loop ----------
  let tSim = 0;
  let dt = 0.005; // init
  function computeDtWrapper(){
    try { dt = computeDt(); } catch(e) { dt = 0.005; }
  }

  function step() {
    updateVelocity(tSim);

    computeDtWrapper();
    const targetSub = Math.max(4, Math.min(10, Math.floor(0.008 / dt)));
    substepsPerFrame = targetSub;

    for (let s=0; s<substepsPerFrame; s++){
      advectC(dt);
      diffuseCH(dt);
      if ((s & 3) === 0) seedNoise();
      tSim += dt;
    }

    const feat = extractFeatures();
    updateAudio(feat, tSim);

    drawField();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

})();
</script>
</body>
</html>