<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Kelvin–Helmholtz • Partículas + Sonido</title>
  
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.85);color:#eee;z-index:10}
    #overlay .panel{text-align:center;max-width:680px;padding:24px}
    #overlay button{border:0;border-radius:16px;padding:14px 22px;font-size:16px;cursor:pointer;box-shadow:0 0 0 1px #555 inset}
    #hud{position:fixed;left:12px;bottom:10px;color:#aaa;font-size:12px;line-height:1.2;user-select:none}
    #hud span{display:inline-block;min-width:60px}
  </style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <h2 style="margin:0 0 8px 0;font-weight:600;color:#fff">Kelvin–Helmholtz: instrumento web</h2>
      <p style="margin:0 0 12px 0;color:#ccc">
        Clic para iniciar AudioContext. Arrastra el mouse en X para variar la longitud de onda de la perturbación. Rueda para cambiar la intensidad de cizalla.
      </p>
      <button id="start">Iniciar simulación + audio</button>
    </div>
  </div>
  <div id="hud">
    <div><span>partículas</span><b id="pN">128</b></div>
    <div><span>U0</span><b id="u0">0.60</b></div>
    <div><span>δ</span><b id="delta">0.22</b></div>
    <div><span>k</span><b id="kval">1.20</b></div>
    <div><span>ganancia</span><b id="gain">-12 dB</b></div>
  </div>

  <!-- three.js desde un CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  ;(() => {
    // Parámetros principales
    const PARTICLES = 128;         // osciladores = partículas (ajustable si tu CPU sufre)
    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;
    const WORLD_W = 12;            // unidades de escena (ancho)
    const WORLD_H = 6.75;          // unidades de escena (alto) ~ 16:9
    let   U0 = 0.60;               // velocidad base de las capas (+/- U0)
    let   delta = 0.22*WORLD_H;    // espesor de la zona de cizalla
    let   k = 1.20;                // número de onda de la perturbación
    const shearMix = 0.55;         // peso en el mapeo de volumen por |dU/dy|
    const vyMix = 0.45;            // peso por |vy|
    const baseGainDB = -12;        // ganancia global
    const freqMin = 20, freqMax = 5000;

    // HUD
    const elPN = document.getElementById('pN');
    const elU0 = document.getElementById('u0');
    const elD  = document.getElementById('delta');
    const elK  = document.getElementById('kval');
    const elG  = document.getElementById('gain');
    elPN.textContent = PARTICLES;
    elU0.textContent = U0.toFixed(2);
    elD.textContent  = (delta/WORLD_H).toFixed(2);
    elK.textContent  = k.toFixed(2);
    elG.textContent  = baseGainDB+" dB";

    // THREE: escena básica
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-WORLD_W/2, WORLD_W/2, WORLD_H/2, -WORLD_H/2, 0.1, 100);
    camera.position.z = 5;
    const renderer = new THREE.WebGLRenderer({antialias:true,alpha:false,preserveDrawingBuffer:false});
    renderer.setSize(WIDTH, HEIGHT);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // Partículas: posiciones + velocidades
    const positions = new Float32Array(PARTICLES * 3);
    const velocities = new Float32Array(PARTICLES * 2); // vx, vy
    const colors = new Float32Array(PARTICLES * 3);

    // Inicialización: dos capas, y ≈ 0 es el interfaz
    const rng = mulberry32(0xC0FFEE);
    for (let i=0;i<PARTICLES;i++){
      const y = (i/(PARTICLES-1))*WORLD_H - WORLD_H/2;       // bottom -> top
      const x = (rng()-0.5)*WORLD_W;                         // dispersión horizontal
      positions[3*i+0]=x;
      positions[3*i+1]=y;
      positions[3*i+2]=0;

      const U = U0 * Math.tanh(y / delta);                   // perfil suave
      velocities[2*i+0] = U + 0.02*(rng()-0.5);              // vx
      velocities[2*i+1] = 0.02*(rng()-0.5);                  // vy pequeño

      const c = khColor(U, 0);                               // color inicial por capa
      colors[3*i+0]=c.r; colors[3*i+1]=c.g; colors[3*i+2]=c.b;
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const mat = new THREE.PointsMaterial({size: 6 / renderer.getPixelRatio(), vertexColors:true, sizeAttenuation:false});
    const points = new THREE.Points(geom, mat);
    scene.add(points);

    // Audio
    let audioCtx=null, master=null, limiter=null;
    const gains=[], oscs=[];
    const startBtn = document.getElementById('start');
    startBtn.addEventListener('click', async () => {
      document.getElementById('overlay').style.display='none';
      await startAudio();
    });

    async function startAudio(){
      audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive', sampleRate: 48000});
      master = audioCtx.createGain();
      master.gain.value = dbToGain(baseGainDB);
      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.value = -10;
      limiter.knee.value = 10;
      limiter.ratio.value = 12;
      limiter.attack.value = 0.003;
      limiter.release.value = 0.12;
      master.connect(limiter).connect(audioCtx.destination);

      // Un oscilador por partícula (cuidado con CPUs viejas)
      for (let i=0;i<PARTICLES;i++){
        const osc = audioCtx.createOscillator();
        osc.type='sine';
        const gn = audioCtx.createGain();
        gn.gain.value = 0.0;
        osc.connect(gn).connect(master);
        osc.start();
        oscs.push(osc);
        gains.push(gn);
      }
    }

    // Perturbación de interfaz y "fuerza" de roll-up
    let t=0;
    let pointerX=0.0, wheel=0.0;
    window.addEventListener('mousemove', (e)=>{
      pointerX = (e.clientX / innerWidth - 0.5) * 2.0; // -1..1
    }, {passive:true});
    window.addEventListener('wheel', (e)=>{
      wheel += Math.sign(e.deltaY)*0.05;
      U0 = clamp(U0 + (-Math.sign(e.deltaY))*0.03, 0.2, 1.5);
      elU0.textContent = U0.toFixed(2);
    }, {passive:true});

    // Animación
    const tmp = new THREE.Color();
    function animate(){
      requestAnimationFrame(animate);
      const dt = 0.016; // ~60 FPS
      t += dt;

      // Ajuste de parámetros por input
      k = clamp(1.2 + pointerX*0.9, 0.2, 2.5);
      delta = clamp(0.22*WORLD_H + 0.10*WORLD_H*Math.sin(t*0.15 + wheel), 0.10*WORLD_H, 0.42*WORLD_H);
      elK.textContent = k.toFixed(2);
      elD.textContent = (delta/WORLD_H).toFixed(2);

      for (let i=0;i<PARTICLES;i++){
        const idx3 = 3*i, idx2 = 2*i;
        let x = positions[idx3+0];
        let y = positions[idx3+1];
        let vx = velocities[idx2+0];
        let vy = velocities[idx2+1];

        // Campo base: U(y)=U0*tanh(y/delta)
        const U = U0 * Math.tanh(y / delta);
        const dUdy = (U0/delta) * sech2(y/delta);  // magnitud de cizalla local

        // Perturbación ondulatoria "semilla" en interfaz (x,y)
        const phase = k*x - 1.2*t;
        const amp = 0.18*WORLD_H * Math.exp(-Math.abs(y)/(0.55*WORLD_H)); // decae lejos de la interfaz
        const py = amp * 0.3 * Math.sin(phase);

        // "Fuerzas" sencillas que inducen roll-up (no-CFD, solo evocación)
        vx += (U - vx) * 0.08;                    // relaja a perfil de cizalla
        vy += (dUdy * 0.05) * Math.cos(phase) + (py - 0.0) * 0.02;

        // Pequeña disipación para estabilidad
        vx *= 0.995;
        vy *= 0.995;

        // Advecta posiciones
        x += vx * dt;
        y += vy * dt;

        // Reentrada horizontal (dominio periódico)
        if (x < -WORLD_W/2) x += WORLD_W;
        if (x >  WORLD_W/2) x -= WORLD_W;

        // Paredes suaves en Y
        if (y < -WORLD_H/2){ y = -WORLD_H/2; vy *= -0.4; }
        if (y >  WORLD_H/2){ y =  WORLD_H/2; vy *= -0.4; }

        // Escribe de vuelta
        positions[idx3+0]=x;
        positions[idx3+1]=y;
        velocities[idx2+0]=vx;
        velocities[idx2+1]=vy;

        // Color: mezcla frío–cálido según U(y) y cizalla
        const shear = Math.min(Math.abs(dUdy)*delta/U0, 1.0); // 0..1
        const col = khColor(U, shear);
        colors[idx3+0]=col.r;
        colors[idx3+1]=col.g;
        colors[idx3+2]=col.b;

        // Audio: freq por altura, volumen biomimético por cizalla y |vy|
        if (audioCtx){
          const y01 = (y + WORLD_H/2)/WORLD_H;           // 0 bottom -> 1 top
          const freq = lerp(freqMin, freqMax, y01);
          const energy = clamp(shearMix*shear + vyMix*Math.min(Math.abs(vy)/(U0*0.8),1.0), 0, 1);
          const gain = Math.pow(energy, 1.5) * 0.02;     // segura con muchos osciladores

          oscs[i].frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
          gains[i].gain.setTargetAtTime(gain, audioCtx.currentTime, 0.05);
        }
      }

      geom.attributes.position.needsUpdate = true;
      geom.attributes.color.needsUpdate = true;
      renderer.render(scene, camera);
    }
    animate();

    // Utilidades
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
    function clamp(x,a,b){return Math.max(a,Math.min(b,x))}
    function lerp(a,b,t){return a + (b-a)*t}
    function sech2(z){const s = 1/Math.cosh(z); return s*s}
    function dbToGain(db){return Math.pow(10, db/20)}

    // Paleta "KH": azul cian en capa inferior, naranja/amarillo donde mezcla y cizalla crecen
    // U > 0 (capa superior) -> cálido; U < 0 (inferior) -> frío; shear mezcla hacia amarillo/blanco
    function khColor(U, shear){
      // base por signo de U
      const cold = new THREE.Color().setHSL(0.58, 0.9, 0.55); // cian-azul
      const warm = new THREE.Color().setHSL(0.08, 0.95, 0.55); // naranja
      const base = U>=0 ? warm.clone() : cold.clone();
      // mezcla hacia brillo alto con shear
      const hot  = new THREE.Color().setHSL(0.13, 1.0, 0.70); // amarillo
      base.lerp(hot, shear*0.75);
      return base;
    }

    // Resize
    window.addEventListener('resize', onResize, {passive:true});
    function onResize(){
      renderer.setSize(innerWidth, innerHeight);
      const aspect = innerWidth/innerHeight;
      const viewH = WORLD_W/aspect;
      camera.top =  viewH/2;
      camera.bottom = -viewH/2;
      camera.updateProjectionMatrix();
    }

  })();
  </script>
</body>
</html>